---
title: 设计模式读书笔记
date: 2020-05-18 10:55:50
tags: coding
categories: 
- 读书笔记
- 设计模式
---

# 设计模式

我一直持有一个观点：代码首先是给人看的，其次才是给机器读的，不然搞什么面向对象又是面向过程，一个文件塞满理论上也能满足计算机的要求，但是想让人看懂，易于操控，就需要理解语言创造者的苦心。而进阶的编程爱好者，对于设计模式的理解便显得弥足珍贵了，本文为多语言各种设计模式的横纵向比较分析与记录。

# 创造者模式

与其说是创造对象，不如说是产品说明，此类模式关心一个实例创造前的全部内容，如同造汽车前，设计和制造流水线工程。

**这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活**

## 工厂模式 Factory Pattern

不涉及创造实例

大部分程序一直在研究的就是解耦，因为高度耦合会带来难以维护，变量联系过于紧密等问题，我们希望模块化，而不是牵一发而动全身，因此创造对象时一大堆初始化工作不应该放在业务代码里，应该有一个工厂一样的接口代为保存，这样核心业务变化的时候，不用在所有创造实例的业务里修改，只需要修改工厂即可。

## 抽象工厂模式 Abstract Factory Pattern

工厂的工厂

当业务复杂化后，需要对工厂本身抽象，进而满足工厂实例跟着业务实例的变化，如流水线核心不变，生产轿车还是跑车这种小细节变化，只需要实例化抽象工厂就能满足要求。

## 单例模式 Singleton Pattern

有且只有自己存在

单例的核心思想是全局唯一性，本类实例化自己，且唯一，外部只能销毁和创建调用，不能去关心内部逻辑。

适用于全局唯一的实例，如单线程。

## 建造者模式 Builder Pattern

核心是造变形金刚

变形金刚由多个部件组成，部件本身复杂多变，但是合体变形金刚的算法或者结构却是相对简单的，这时考虑使用建造者模式。

比起工厂模式更关心部件的组装顺序。

## 原型模式 Prototype Pattern

克隆人

当新建对象代价很大的时候，对象需要复用时使用。

如一个对象需要在一个高代价的数据库操作之后被创建。可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## 对象池模式 Pool

水库存水

老是用水龙头取水，水龙头容易坏，还容易无法满足需求，先搞个水库，把常用对象扔进去，异步的存取使用，避免同步操作带来的消耗。

如：线程池、数据库连接池、任务队列池、图片资源对象池。

举例：laravel 的邮件发送是同步的，修改成一个队列池，每个新请求会被放到池子里，服务器可以从容不迫的 FIFO 处理任务。 

## 多例模式 Multiton

包含多个实例的单例模式

如多个数据库链接。

## 静态工厂模式 Static Factory

针对静态资源的工厂模式

# 结构型模式

## 适配器模式 Adapter Pattern

电力中的转换器也是相同思路，220v 换成 120v 需要一个接口处理，就是适配器。

当年写 Android 的时候，适配器是必须掌握的知识。

缺点就是反常规，看不懂会奇怪，明明 A 类的资源，怎么扔 B 类还能用？

## 桥接模式  bridge Pattern

桥接的核心思路是将抽象与行为解耦，从继承关系弱化为关联模式

如一个实例面临多个并列行为的关系时，可以用桥接，如设计一杯饮料，杯子大小，饮料内容，配料均有多个选择，使用桥接很适合。

## 共享模式 Flyweight

核心是高度重复资源的可重复利用性，多跟工厂模式共用，当遇到请求时，首先检索共享池里是否有合适对象，否则创造并返回。

面临高度重复的请求时，最大程度减少资源开销。

## 装饰模式 Decorator

动态基于对象新的功能，像打补丁一样，不在意被装饰对象本身细节。

相当于万智牌的合变放在下面，下面的生物只给了异能，别的啥事没干。

## 组合模式 Composite

本质上是树形结构的封装利用，利用树形结构的访问速度优势，迭代得获取各组件。

非叶节点也可以看成另一个组构体。

## 代理模式 Proxy Pattern

核心在于请求本身涉及安全性或者大花销等问题，需要代理看看给不给权限，不然对象造完了再研究给不给权限就没什么意义了。

相当于请个管家管一下。

## 外观模式 Facade

比起小管家，Facade 是总管，对一个系统的访问做整理跟统筹，最大程度降耦，保证子系统自由性。

# 行为类模式

## 迭代模式 Iterator

迭代器的抽象，没啥好说的，核心在于不暴露内部结构的遍历。

## 模板模式 Template

定义操作骨架，通过继承丰富内容或者实现。

抽象类常用思想，定义却不完化，给予后人补充说明。

## 责任链 Chain of Responsibility

请求来源高度不确定性，使用 cor 可以使链上任意一个类的负担不至于过重，统一一个 handler 分配工作。

## 备忘模式 Memento

可能二次需要的内容做保存。

如 laravel 中的 `old()`方法。

## 中介者 Mediator

各个对象之间的交互操作非常多;每个对象的行为操作都依赖彼此对方,修改一个对象的行 为,同时会涉及到修改很多其他对象的行为。

如 laravel 中的 `Controller`

## 解释器 Interpreter

很少会用到，关注于非可识别语言的解释，如正则，表达式等。

## 策略模式 Strategy

也叫算法簇模式，针对不同需求，有策略的分派不同算法解决问题。

## 状态模式 State 

就是状态机。

## 观察者 Observer 

常驻内存检测变化，一旦变化就触发。

## 访问者模式 visitor

作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义 作用于这些对象的新操作. 

## 命令模式 Command 

Laravel 中的 Artisan 是很典型的命令模式，请求对象化。